<!DOCTYPE html>
<html>
<meta charset="utf-8">
<head>
  <title>Teach Brian How to Code</title>
  <link rel="stylesheet" href="stylesheets/blog-stylesheet.css" type="text/css">
  </head>
  <body>
    <div class="sub-div">
      <p><a href="../index.html">Back to Home</a></p>
    </div>
<main>
  <h6>Becoming Javascript Queen</h6>
  <h2>July 21, 2015</h2>
  <div class=tech-div>
    <h4>How to master JavaScript</h4>
    <p>After two unsuccessful javascript interviews, I decide to take some time and study in depth. Like it or not, JavaScript developer positions are much more than Ruby developer positions and I just can't ignore powerful libraries and their scalability! So What is JavaScript?</p>
    <p>JS is a single threaded lagnauge. JS is a dynamic, weakly typed, prototype-based language with <strong>first-class functions</strong>. If you think about it, DOM is JavaScript representation of HTML and browser. </p>
    <p>First, let's see how JS memory and variable works.</p>
    <img src='Screen-shot/varmemory.png'>
    <p>In this example, JS created the variable sum as a function and skip the function body. Next, It will create a, b and assigned to number and an object. When it try to create the variable c, it will invoke the function sum and then reads the function body. a and b becomes x and y and then it will return the result, which is 2 + 3 = 5</p>
    <p>Let's pretend there is a new variable d. If you call d = sum(a,b), what happen?</p>
    <p>It will still return 5. Because the system will create new variable d apart from c and assigned to sum(a,b) like they don't know nothing about c. </p>
    <p>As you can guess, if you call c(); it will returns 7. It is because it will bring c value and then execute again.</p>
    <p>Let's observe weired behavoir of javascript double and triple equal rules</p>
    <h4> '==' and '===' :The Performance Difference </h4>
    <div class="text-editor">
      21 == '21' //true
      undefined == null //true
      undefined === null //false
      21 === 21 //true
      {} === {} //false - because they only compare the memory address of the two different objects.
      NaN === NaN //false
      true == {valueOf: function() {retur "1"}} //true - because they are trying to convert bullean value to ingeter 1. So it becomes a question of 1 == '1'
    </div>
    <p>So when we using ==, this will increse look up time dramatically if they have to match different type of things. For instance, if they want to see if true and the function returns '1' are equal(==), then it will first see if true can be validated as something else like integer and then convert to 1. And then it will see if this will be match with the string of '1'. And then finally it will determine 1 and '1' are same thing. So this is about the performance issue, not anything else.</p>
    <p>Note: I don't think this is super important or anything but 'Method' is function belongs to a object(so it is property of an object), function is just general scope of function</p>
    <p>There is also term called 'Native Array Method' which is like 'unshift' and 'push' in array. Function on array comes out of box of Javascript. </p>
    <div class="text-editor">
      *Special key word 'arguments'
      var add = function(a,b) {
        console.log(arguments);
      };
      add(3, 4, 5)
      // [3,4,5] in array like format
    </div>
    <h4>Scope scope scope!!!</h4>
    <div class='text-editor'>
    var extra = 'chocolate';
    var blender = function(fruit) {
      var x = fruit ;
      var y = 'yogart';

      var delic = function() {
        var ingred = 'milk';
        console.log( fruit + ' and '+ y + ' and ' + extra)
      };

      console.log("The x is " + ingred);
      delic();
    }
    blender('strawberry');
    //this will throw ReferenceError: ingred is not defined
    </div>
    <p>Conclusion: Parent can't access children's variables(ingred) but children can access parent's variables(x, y).</p>
    <p> function 'delic' can't be execute outside of the parent function 'blender'. The reason is that delic is a private function of blender. </p>
    <div class='text-editor'>
      var outerCounter = 10;
      var fn = function () {
        outerCounter = outerCounter + 1;
        ACTUAL = outerCounter;
      };

      fn();
      expect(ACTUAL === 11).to.be.true;
      console.log(outerCounter) // 11
      fn();
      expect(ACTUAL === 12).to.be.true;
      console.log(outerCounter) // 12
    </div>
    <p>Because outerCounter is a global variable, it can be reset from anywhere. Compare with the following exercise</p>
    <div class='text-editor'>
      var fn = function () {
        var innerCounter = innerCounter || 10;
        innerCounter = innerCounter + 1;
        ACTUAL = innerCounter;
      };

      fn();
      expect(ACTUAL === 11).to.be.true;
      fn();
      expect(ACTUAL === 11).to.be.true;
    </div>
    <p>A new variable scope is created for every call to a function. </p>
    <h4>Closure </h4>
    <div class=text-editor>
      var closureAlert = function() {
        var x = 0;
        var alerter = function() {
          alert(++x);
        }
        return alerter;
      }

      myclosureAlert = closureAlert();
      myclosureAlert();
      // myclosureAlert is a 'closure'. It holds the reference to the environment.
    </div>
    <p>One thing really important to understand is why we use 'closure'. A 'closure' is to store the function inside of the function so it can be called later. So in general, the parent function will 'return' the child function (but it will NOT invoke the function) which can be stored in variable outside of the parent function. Thus it can be invoked later. </p>
    <p>Let's look at one funny example of how closure works in memory.</p>
    <img src='Screen-shot/closure.png'>
    <p> So what a[0]();, a[0]();, a[0](); will return? The answer is 3. The green arrow will follow through the problem and pointed out the variable i which is 3. That's the reason it returns 3 every single time. One funny thing is that although i supposed to be less than 3 but it will be 3 and then it will stop the loop. That's why the answer is not 2, but 3. Pretty crazy, huh?</p>

  </div>
</main>
 <hr>
      <footer>
        Sarah Kwak 2015 &#169; copyrights
      </footer>
  </body>
</html>